//
//  main.cpp
//  Reference3
//
//  Created by abbas raza on 7/11/17.
//  Copyright Â© 2017 Self. All rights reserved.
//

/* Purpose of this program:
 - To explore references.
   https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in/57492#57492
 1) Reference requires initialization with declaration.

	int& ref_of_var = var;
	int& ref_of_var; this will fail
 
 2) Reference can't be null
 
	 int& ref_of_var = NULL; // won't compile
 
	 int &x = *(int*)0; ---> This will result in undefined behaviour.

    Similarly this will be undefined:
	 int * ptr = NULL;
	 int &x = *ptr;
 
 3) Address of reference is same as address of var. Both print same address in below snippet

	int var = 10;
	int& ref_of_var = var;
	
	std::cout << "Address of var " << &var << std::endl;
	std::cout << "Address of reference " << &ref_of_var << std::endl;

 4) A reference once assigned to var, can't be re-directed to some other variable.
 
 5) A reference can't be incremented like pointers to iterate through an array.
 
	int array_of_int[] = {10,19};
	
	int& ref_of_array = array_of_int[0];
	int * ptr_to_array = array_of_int;
	
	std::cout << ref_of_array << std::endl; ---> prints 10
	std::cout << *ptr_to_array << std::endl; --> prints 10
 
	ref_of_array++; // will not point to next index.
	ptr_to_array++; // will point to next index
	
	std::cout << ref_of_array << std::endl; ---> prints 11
	std::cout << *ptr_to_array << std::endl; --> prints 19

 6) Pointer and reference have same assembly generated by compiler. i.e reference has
    same stack/heap space as pointer.
 
 7) We can have pointer to pointer and so on. But references are single level of indirection.
    We can't have reference to reference. Because reference is nothing but just alias of a variable.
    Regardlress of assembly code, address of reference is same as address of variable its referencing to.
 
	 int var = 10;
	 int * ptr1 = &var;
	 int ** ptr2 = &ptr1;
 
	 int& ref = var;
	 int&& ref2 = ref; --> can't do this.

 8)  A pointer needs to be dereferenced with * to access the memory location it points to, whereas a reference can be used directly. A pointer to a class/struct uses -> to access it's members whereas a reference uses a dot.
 
 9) Reference is like constant pointer. But safe?
	 int var = 10;
	 int * const ptr_to_var = &var;
	 int& ref_of_var = var;

 10) Pointer to reference. This doesn't exist.
	 Because reference is nothing but just alias of a variable. Regardlress of assembly code,
	 address of reference is same as address of variable its referencing to.
 
 11) Reference to pointer. i.e alias to pointer. or othername of pointer.

	 int var = 10;
	 int *  ptr = &var;

	 int*& ref_to_ptr = ptr; ---> ref_to_ptr is a reference to pointer ptr
 
	 ref_to_ptr = 0; 	---> this means ptr = 0
	 ref_to_ptr = NULL; ---> this means ptr = NULL
 
	 *ref_to_ptr = 0; 	---> this means *ptr = 0
 
    ==== reference to pointer vs pointer to pointer =====
	 void bar(int **ptr)
	 {
		 **ptr = 20; ---> means var = 20

		 *ptr = NULL; ---> means original_ptr = NULL
	 }
 
	 void foo(int*& ptr)
	 {
		 *ptr = 20;  ---> means var = 20

		 ptr = NULL; ---> means original_ptr = NULL
	 }
 
	 int main(int argc, const char * argv[])
	 {
		 int var = 10;
		 int * original_ptr = &var;
		 bar(&original_ptr);
 
		 foo(original_ptr);
		 std::cout << *original_ptr << std::endl;
 
		 return 0;
	 }
  ======================================================================

 12) Use references in function parameters and return types to define useful and self-documenting interfaces.
	 Use pointers to implement algorithms and data structures.
	 http://yosefk.com/c++fqa/ref.html
 
 13) Array of references. We can't have that.
	 int& array_of_ref[1] = {var}; ---> can't do this
	 int*& array_of_ref_to_ptr[1] = {ptr}; --> can't do this.
 
 14) Const references can be bound to temporaries. Pointers cannot (not without some indirection):
	 safe usage in argument list.
 
	 const int& x = 12; //	legal C++
	 int * y = &(12); 	//	illegal to dereference a temporary.
 
	 This makes const& safer for use in argument lists and so forth.
 
	 std::string s1 = "Hello";
	 std::string s2 = "World";
 
	 std::string s3 = s1 + s2;
	 Here sum of s1 and s2 is put into temporary and then copied to s3.
	 The life time of temporary is expression. After expression has executed,
	 temporary is gone.
 
	 const std::string& s3 = s1 + s2;
	 Here sum of s1 and s2 is put into temporary and then constant reference s3
	 will be alias of that temporary. No copying involved.
	 So lifetime of temporary becomes lifetime of const reference.
 
 15) >> A reference to non-const int can be const and non const.
	 reference to int
	 int var = 10;
	 int& ref_of_var = var;
	 ref_of_var = 20; --> will change var to 20
 
	 const reference to int
	 int var = 10;
	 const int& ref_of_var = var;
	 ref_of_var = 20; --> won't compile

	 >> A reference to const int can only be const.
 
	 non const reference to const int: (not possible)
	 const int var = 10;
	 int& ref_of_var = var; --> won't compile

	 const reference to const int:
	 const int var = 10;
	 const int& ref_of_var = var;
	 ref_of_var = 20; --> can't do this
 
 16) Pointers are more cumbersome to use, thus violating the language design principle
	 that the best-practice solution should be easier than the alternatives.
*/


#include <iostream>

int main(int argc, const char * argv[])
{
	std::cout << "Look at the comments above to learn about references" << std::endl;
	return 0;
}

